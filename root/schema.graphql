type Checkpoint @entity {
  id: ID!
  proposer: Bytes!
  headerBlockId: BigInt!
  checkpointNumber: BigInt!
  reward: BigInt!
  start: BigInt!
  end: BigInt!
  root: Bytes!
  transactionHash: Bytes!
  timestamp: BigInt!
}

type StateSync @entity {
  id: ID!
  stateId: BigInt!
  contract: Bytes!
  data: Bytes!
  transactionHash: Bytes!
  timestamp: BigInt!
}

type StateRegistration @entity {
  id: ID!
  user: Bytes!
  receiver: Bytes!
  sender: Bytes!
}

# This entity will hold everything regarding
# plasma exit
#
# Not all fields are made compulsory due to the fact,
# all steps don't happen at a time, rather they will be async ops
type PlasmaExit @entity {
  # id always created using `plasma-exit-${exitId}`
  id: ID!
  exitId: BigInt!
  exitInitiator: Bytes
  exitCompleter: Bytes
  token: Bytes
  amount: BigInt
  isRegularExit: Boolean!
  exited: Int!
  # exited can take 3 possible values
  # 0 -> exit started
  # 1 -> exit cancelled
  # 2 -> exit completed
  exitStartedTxHash: Bytes
  exitStartedTimeStamp: BigInt
  exitCancelledTxHash: Bytes
  exitCancelledTimeStamp: BigInt
  exitCompletedTxHash: Bytes
  exitCompletedTimeStamp: BigInt
}

type PredicateRegistration @entity {
  id: ID!
  tokenType: Bytes!
  predicateAddress: Bytes!
  timestamp: BigInt!
  transactionHash: Bytes!
}

type TokenMapping @entity {
  id: ID!
  rootToken: Bytes!
  childToken: Bytes!
  tokenType: Bytes!
  timestamp: BigInt!
  transactionHash: Bytes!
}

type Validator @entity {
  id: ID!
  validatorId: BigInt!
  # Below could be added, but that causes one
  # issue : In handler function how should we be able to
  # understand which chain we're currently working with ?
  #
  # Because that affects our which contract should be called
  # for checking ownership of NFT contract
  #
  # It's better done offline, before serving request, backend can
  # query blockchain node for this piece of data using standard `ownerOf`
  # function call of standard ERC721, where parameter should be passed `validatorId`
  #
  # owner: Bytes!
  signer: Bytes!
  signerPubKey: Bytes!
  liquidatedRewards: BigInt!
  activationEpoch: BigInt!
  deactivationEpoch: BigInt!
  totalStaked: BigInt!
  commissionRate: BigInt!
  nonce: BigInt!
  unstaked: Boolean!
  jailEndEpoch: BigInt!
  auctionAmount: BigInt!
  isInAuction: Bool!
}

type Delegator @entity {
  id: ID!
  validatorId: BigInt!
  address: Bytes!
  # total delegated amount
  delegatedAmount: BigInt!
  # total unclaimed amount (after sellVoucher and before claiming it)
  unclaimedAmount: BigInt!
  # total claimed amount (after withdraw delay, while claiming unstaked amount)
  claimedAmount: BigInt!
  # total current shares (works until tokens are non-transferable)
  tokens: BigInt!
  claimedRewards: BigInt!
}

# Heimdall topups
type Topup @entity {
  id: ID!
  address: Bytes!
  topupAmount: BigInt!
  withdrawAmount: BigInt!
}

# Staking Params across all validators
type StakingParams @entity {
  id: ID!
  owner: Bytes
  validatorThreshold: BigInt!
  proposerBonus: BigInt!
  dynasty: BigInt!
  liquidatedRewards: BigInt!
}

# Staking NFT's historical ownership
# can be checked using this entity
type StakingNFTTransfer @entity {
  id: ID!
  tokenId: BigInt!
  currentOwner: Bytes!
  previousOwners: [Bytes!]!
  transactionHashes: [Bytes!]!
}
